Para llevar a cabo este estudio se implementa una programa, mediante el lenguaje de programación Python, encargado de aplicar el heurístico desarrollado sobre los repositorios alojados tanto en GitHub como en GitLab.
Dicho programa se puede encontrar junto con su licencia Apache 2.0 en la siguiente url:\\
\url{https://github.com/jorcontrerasp/CIReposFinder}

\section{Herramientas utilizadas}
Las herramientas que se han utilizado para elaborar el programa son las siguientes:
\subsection{Python}
Es un lenguaje de programación cuya filosofía hace hincapié en la legibilidad del código. Sus principales características son las siguientes:
\begin{compactitem}
    \item Multiparadigma: ya que más que forzar a los programadores a adoptar un estilo de programación, permite varios estilos, soportando la orientación a objetos, la programación imperativa y la funcional.
    \item Interpretado.
    \item Dinámico: permitiendo que una variable pueda tomar valores de distinto tipo.
    \item Multiplataforma.
\end{compactitem}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.3\textwidth,clip=true]{\logoPython}
    \caption{Logo de Python.}
\end{figure}

\subsection{API de GitHub}
API REST que nos va a permitir utilizar diferentes métodos para obtener información acerca de los repositorios almacenados en GitHub.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.2\textwidth,clip=true]{\logoGitHub}
    \caption{Logo de GitHub.}
\end{figure}

\subsection{API de GitLab}
API REST que nos va a permitir utilizar diferentes métodos para obtener información acerca de los repositorios almacenados en GitLab.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth,clip=true]{\logoGitLab}
    \caption{Logo de GitLab.}
\end{figure}

\subsection{Visual Studio Code}
Visual Studio Code es un editor de código fuente ligero disponible para Windows, macOS y Linux. Viene con soporte incorporado para JavaScript, TypeScript y Node.js y tiene un rico ecosistema de extensiones para otros lenguajes  (como C++, Java, Python, PHP o Go) y tiempos de ejecución (como .NET y Unity).
En este trabajo se va a utilizar tanto para la implementación del programa en Python encargado de obtener información sobre integración continua como para la escritura de la memoria final en LaTeX.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.3\textwidth,clip=true]{\logoVscode}
    \caption{Logo de Visual Studio Code.}
\end{figure}

\section{Implementación Python}
\cotutor{Yo llamaría a la sección ``Implementación de la herramienta""}

\cotutor{Más que enumerar los ficheros que se han utilizado para la implementación de la herramienta, sería más útil y compacto una figura o diagrama que muestre como se ha implementado. Sobre esta figura ya puedes contar como funciona/se utiliza tu herramienta}

\subsection{Ficheros Python}
El programa localizador de proyectos que utilizan CI cuenta con los ficheros descritos a continuación:
\begin{compactitem}
    \item \textbf{aux\_functions.py}: script de python que contiene funciones auxiliares en las que se apoyará el programa principal.
    \item \textbf{ci\_tools.py}: script en el que se definen todas las herramientas de integración continua que se van a buscar en el proceso junto con la forma en la que se van a encontrar dichas herramientas, es decir, contiene las instrucciones que conforman el heurístico de búsqueda.
    \item \textbf{ci\_yml\_parser.py}: script que transforma las etiquetas de ficheros YML a objetos Python con el objetivo de que sean tratados  de forma trivial al devolver la información que contengan.
    \item \textbf{config.yml}: fichero en el que se definen todas las variables de configuración del proceso de búsqueda.
    \item \textbf{dataF\_functions.py}: script contenedor de todas las funciones relacionadas con la gestión de la estructura de datos utilizada ``DataFrame'' para generar la información de retorno.
    \item \textbf{github\_queryMaker.py}: script que permite construir consultas con el formato aceptado por la API de GitHub.
    \item \textbf{github\_search.py}: script en el que se realiza la búsqueda de repositorios GitHub.
    \item \textbf{github\_tests.py}: script utilizado para aplicar el heurístico sobre un repositorio GitHub concreto, es decir, permite realizar pruebas unitarias sobre repositorios GitHub.
    \item \textbf{gitlab\_search.py}: script en el que se realiza la búsqueda de repositorios GitLab.
    \item \textbf{gitlab\_tests.py}: script utilizado para aplicar el heurístico sobre un repositorio GitLab concreto, es decir, permite realizar pruebas unitarias sobre repositorios GitLab.
    \item \textbf{main.py}: script que se llaman a todos las funciones necesarias para realizar el proceso de búqueda de repositorios. Conforma el programa principal.
    \item \textbf{project\_cleaner.py}: script que va a permitir limpiar el proyectos de ficheros que ya no sirvan o temporales (ficheros excel de resultados, ficheros pickle y ficheros de log).
    \item \textbf{convertExcel2LaTeX.py}: script que va a permitir convertir las tablas de los ficheros excel de resultados en código fuente LaTeX con el objetivo de facilitar la escritura de las mismas en la memoria del trabajo.
\end{compactitem}

El proceso que lleva a cabo este programa Python se ha programado de tal forma que sea configurable mediante el fichero ``config.yml''. Este fichero de configuración cuenta con tres partes bien diferenciadas:

\begin{enumerate}
    \item etiqueta \textbf{process}, con variables genéricas relacionadas con la configuración del proceso.
    \begin{compactitem}
        \item \textbf{execute}: indica si se ejecuta o no el proceso en su totalidad.
        \item \textbf{doGithubSearch}: indica si se ejecuta o no la búsqueda sobre repositorios GitHub.
        \item \textbf{doGitlabSearch}: indica si se ejecuta o no la búsqueda sobre proyectos GitLab.
        \item \textbf{usePickleFile}: indica si se utiliza o no un fichero binario de Python con extensión ``.pickle'' para obtener los repositorios, que fueron recuperados previamente en una búsqueda anterior, a los que se les aplicará el heurístico.
        \item \textbf{useResultsExcelFile}: indica si se continúa rellenando un fichero de resultados excel ya existente.
        \item \textbf{tmpDirectory}: variable que almacena el directorio de ficheros temporales.
        \item \textbf{tmpFile}: variable que almacena el nombre raíz de los ficheros temporales que se vayan utilizando en el proceso.
    \end{compactitem}
    \item etiqueta \textbf{github}, con variables relacionadas con la configuración de la búsqueda GitHub.
    \begin{compactitem}
        \item \textbf{queryFile}: indica qué consulta es la que se va a utilizar en la búsqueda sobre repositorios GitHub.
        \item \textbf{filterCommits}: indica si se filtra o no por el número de ``commits'' que tienen los repositorios.
        \item \textbf{MAX\_COMMITS}: en el caso de filtrar por ``commits'', indica el número máximo que tendrán los repositorios.
        \item \textbf{MIN\_COMMITS}: en el caso de filtrar por ``commits'', indica el número mínimo que tendrán los repositorios.
        \item \textbf{randomizeRepos}: indica si se obtienen ``n'' repositorios aleatorios de la lista inicial obtenida para aplicar el heurístico.
        \item \textbf{N\_RANDOM}: indica, en el caso de que se marque la opción ``randomizeRepos'', el número de repositorios aleatorios que se obtendrán.
        \item \textbf{onlyPositives}: indica si se devuelven única y exclusivamente repositorios positivos en los ficheros de resultados.
    \end{compactitem}
    \item etiquerta \textbf{gitlab}, con variables relacionadas con la configuración de la búsqueda GitLab.
    \begin{compactitem}
        \item \textbf{search1By1}: indica si se aplicará el heurístico a cada proyecto según se vayan encontrando o si, por el contrario, se obtienen todos los proyectos y a continuación, una vez obtenidos, se recorren para aplicarles el heurístico. Si buscamos solo positivos, ``search1By1'' será verdadero en cualquier caso (aspectopor programa), sin tener en cuenta el valor que venga en el fichero de configuración.
        \item \textbf{N\_ERROR\_PAGE\_ATTEMPTS}: indica el número máximo de intentos a ejecutar en caso de que la llamada a la API de GitLab falle.
        \item \textbf{LANGUAGE}: indica el lenguaje en el que tendrán que estar implementados los proyectos GitLab analizados.
        \item \textbf{N\_MAX\_SEARCHES}: indica el número máximo de búsquedas que se van a realizar.
        \item \textbf{N\_MIN\_STARS}: indica el número mínimo de estrellas que tendrán que tener los proyectos GitLab analizados.
        \item \textbf{onlyPositives}: indica si se devuelven única y exclusivamente proyectos positivos en los ficheros de resultados.
        \item \textbf{N\_MAX\_PROJECTS}: si solo buscamos positivos, N\_MAX\_PROJECTS será el nº máximo de positivos a encontrar. Si buscamos tanto positivos como negativos, N\_MAX\_PROJECTS será el número máximo de projectos que tratará (sean o no positivos en CI).
    \end{compactitem}
\end{enumerate}

\subsection{Librerías utilizadas}
Las librerías utilizadas para la implementación del programa son las siguientes:
\begin{compactitem}
    \item \textbf{PyGithub}: librería que facilita el uso de la API de GitHub v3. Permite la gestión de diferentes recursos de GitHub (repositorios, perfiles de usuario, organizaciones, etc.) desde scripts Python.
    \item \textbf{Python-Gitlab}: librería que facilita el uso de la API v4 de GitLab y proporciona una herramienta CLI (Command Line Interface). Permite la gestión de diferentes recursos sobre proyectos almacenados en GitLab desde scripts Python.
    \item \textbf{Pandas}: iniciada en 2008, es una librería que pretende ser el bloque de construcción fundamental de alto nivel para realizar análisis de datos prácticos del mundo real en Python. Además, tiene el objetivo más amplio de convertirse en la herramienta de análisis/manipulación de datos de código abierto más potente y flexible disponible en cualquier idioma. Nos va a permitir manejar DataFrames y convertir la información que queramos tanto en formato excel como en formato csv para su posterior estudio.
    \item \textbf{Pickle}: importando esta librería en el proyecto vamos a poder almacenar la información que queramos en un fichero binario de Python. En este caso, una vez obtenidos los repositorios a analizar se almacenarán en un fichero de este tipo para poder reutilizar esos repositorios en posteriores ejecuciones.
    \item \textbf{Base64}: este módulo proporciona funciones para codificar datos binarios en caracteres ASCII imprimibles y decodificar dichas codificaciones en datos binarios.
    \item \textbf{PyYaml}: PyYAML es un marco YAML con todas las funciones para el lenguaje de programación Python. Nos va a permitir transformar ficheros con extensión YAML o YML en diccionarios Python en formato json.
    \item \textbf{Shutil}: librería que, mediante la instrucción ``rmtree'' va a permitir borrar carpetas de ficheros temporales utilizados para analizar cada repositorio GitHub/GitLab.
    \item \textbf{Json}: librería que va a permitir transformar textos en formato json en un objeto diccionario de Python.
\end{compactitem}

\subsection{Ficheros resultantes}
Tras cada ejecución del proceso, se van a generar varios ficheros en local con información relevante sobre estos sistemas de integración continua para su posterior análisis. Estos ficheros son:
\begin{compactitem}
    \item \textbf{github/github\_results.xlsx}: Fichero excel que va a componer una matriz repositorio de GitHub/herramienta de CI indicando en su intersección mediante una ``***'' si es o no positivo.
    \item \textbf{github/github\_languages.xlsx}: Fichero excel que va a componer una matriz lenguaje (de los repositorios GitHub encontrados)/herramienta de CI indicando el número de repositorios positivos en el lenguaje X y la herramienta de CI Y.
    \item \textbf{github/github\_ci\_statistics.xlsx}: Fichero excel en el que se van a recoger, por cada sistema de CI, datos estadísticos como el mínimo, el máximo, la media y la mediana relativos a la búsqueda que se haya realizado sobre repositorios GitHub.
    \item \textbf{github/github\_language\_statistics.xlsx}: Fichero excel en el que se van a recoger, por cada lenguaje de programación encontrado, datos estadísticos como el mínimo, el máximo, la media y la mediana relativos a la búsqueda que se haya realizado sobre repositorios GitHub.
    \item \textbf{github/github\_stage\_statistics.xlsx}: Fichero excel en el que se van a ir almacenando los contadores de los escenarios de ejecución o ``stages'' encontrados en el proceso de búsqueda GitHub.
    \item \textbf{repos\_github.pickle}: Fichero binario de Python en el que se van a almacenar los repositorios GitHub utilizados a la hora de aplicar el heurístico.
    \item \textbf{gitlab/gitlab\_results.xlsx}: Fichero excel que va a componer una matriz repositorio de GitLab/herramienta de CI indicando en su intersección mediante una ``***'' si es o no positivo.
    \item \textbf{gitlab/gitlab\_languages.xlsx}: Fichero excel que va a componer una matriz lenguaje (de los repositorios GitLab encontrados)/herramienta de CI indicando el número de repositorios positivos en el lenguaje X y la herramienta de CI Y.
    \item \textbf{gitlab/gitlab\_ci\_statistics.xlsx}: Fichero excel en el que se van a recoger, por cada sistema de CI, datos estadísticos como el mínimo, el máximo, la media y la mediana relativos a la búsqueda que se haya realizado sobre repositorios GitLab.
    \item \textbf{gitlab/gitlab\_language\_statistics.xlsx}: Fichero excel en el que se van a recoger, por cada lenguaje de programación encontrado, datos estadísticos como el mínimo, el máximo, la media y la mediana relativos a la búsqueda que se haya realizado sobre repositorios GitLab.
    \item \textbf{gitlab/gitlab\_stage\_statistics.xlsx}: Fichero excel en el que se van a ir almacenando los contadores de los escenarios de ejecución o ``stages'' encontrados en el proceso de búsqueda GitLab.
    \item \textbf{repos\_gitlab.pickle}: Fichero binario de Python en el que se van a almacenar los repositorios GitLab utilizados a la hora de aplicar el heurístico.
    \item \textbf{counting.xlsx}: Fichero excel con un conteo de los excel de resultados tanto en GitHub como en GitLab a modo de resumen.
\end{compactitem}

\section{Proceso de ejecución}
La implementación del programa está dividida en dos partes bien diferenciadas: una encargada de ejecutar el proceso \add{de minado} sobre repositorios GitHub y la otra sobre repositorios GitLab. En cada parte se utilizará para su cometido la API correspondiente a los repositorios a los que se les está aplicando el proceso de búsqueda.

En primer lugar se comprueba mediante la variable ``execute'' si se desea ejecutar o no el proceso en su totalidad. En el caso de que dicha variable sea afirmativa se iniciará el proceso generando las estructuras de datos necesarias que se irán completando con datos obtenidos por el proceso de búsqueda. 

Estas estructuras de datos son los ``DataFrame'' de resultados (matriz de proyectos y sistemas de CI), de lenguajes (matriz de lenguajes y sistemas de CI), de contadores y de estadísticas de datos obtenidos a partir de los ficheros de configuración de estos sistemas (estadísticas de sistemas de CI, lenguajes y escenarios de ejecución de trabajos), las cuales pueden ser generadas de cero o recuperadas a partir de ficheros excel ya generados con anterioridad en función de la variable de configuración ``useResultsExcelFile''.

A continuación, el programa prosigue ejecutando el proceso de búsqueda sobre GitHub y acto seguido sobre GitLab, siempre y cuando las variables ``doGitHubSearch'' y ``doGitLabSearch'' respectivamente sean positivas.

En cuanto a la parte de ejecución sobre repositorios de la plataforma GitHub, en primer lugar se carga la lista de repositorios que va a ser utilizada para aplicar el heurístico. Esta se puede recuperar mediante la carga desde un fichero binario de Python con extensión ``.pickle'' o se puede generar desde cero mediante una llamada a la API de GitHub, en función del valor de la variable de configuración ``usePickleFile''.

Una vez obtenida la lista de repositorios se aplica el heurístico a cada uno de ellos y se irán rellenando las estructuras de datos ya mencionadas con la información que se vaya obteniendo a medida que se ejecuta el proceso. Estas estructuras de datos se devuelven en formato excel en aras de poder ser interpretadas de forma sencilla.

En cuanto a la parte correspondiente a la ejecución sobre proyectos GitLab, al igual que en la parte GitHub ya mencionada, se pueden obtener los repositorios cargados desde un fichero binario de Python con extensión ``.pickle'' o se pueden recuperar mediante una llamada a la API de GitLab. En el caso de que se tenga que llamar a la API de GitLab para generar los repositorios, se diferencian dos formas de actuar en función de la variable de configuración ``search1By1'': obteniendo los repositorios y aplicar el heurístico a la lista que se genere, o ir aplicando el heurístico uno a uno según se vaya cargando la lista de repositorios.

Finalmente, se transforman las estructuras de datos de tipo ``DataFrame'' proporcionadas por la librería ``Pandas'' en formato Excel o Csv.

A modo de resumen, se expone a continuación el flujo de ejecución del programa:

\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth,clip=true]{\flujoGitHub}
    \caption{Flujo de ejecución GitHub.}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=1.25\textwidth,clip=true]{\flujoGitLab}
    \caption{Flujo de ejecución GitLab.}
\end{figure}

\section{Dificultades y problemas encontrados}
En la realización de este trabajo se han ido encontrando diferentes errores que han supuesto un impedimento a la hora de continuar. 

Los más comunes han sido los siguientes:

- Resulta que la API de GitHub nos permite crear llamadas para obtener información sobre los diferentes repositorios que contiene, y de esta manera poder integrar nuestra aplicación con GitHub, pero con una limitación de 60 peticiones a la hora, número insuficiente para realizar una búsqueda masiva que devuelva una cantidad aceptable de repositorios con la que poder llevar a cabo el estudio de manera objetiva. En el momento en el que se utilizan más de los que esta API puede tratar se lanza la siguiente excepción: 

\alumno{No se ve bien la excepción. Revisar.}
\textit{github.GithubException.RateLimitExceededException: 403 \{``message'': ``API rate limit exceeded for user ID 77851630.'', ``documentation\_url'': ``https://docs.github.com/rest/overview/resources-in-the-rest-api\#rate-limiting''\}}

Generando un token de autenticación podemos incrementar el número de peticiones por hora de 60 a 5000 [AÑADIR ANEXO DE GENERACIÓN DE TOKEN GITHUB]. Sin embargo, este número incrementado de peticiones sigue siendo insuficiente para poder ejecutar el proceso de forma masiva sobre un número muy grande de repositorios.

Como solución, mediante la función ``get-rate-limit()'' \ref{lst:control_github_api} de la API de GitHub, antes de gastar una consulta a esta API, se obtiene el número de peticiones restantes y al llegar al límite se pausa el proceso tanto tiempo como sea necesario para recuperar dichas peticiones. Una vez recuperadas las peticiones se prosigue con la ejecución desde donde se dejó en espera.

\begin{lstlisting}[language=Python, caption=Control del nº de peticiones a la API GitHub, label={lst:control_github_api}]
def doApiRateLimitControl():
    try:
        g = authenticate()
        rl = g.get_rate_limit()
        rl_core = rl.core
        core_remaining = rl_core.remaining
        rl_search = rl.search
        search_remaining = rl_search.remaining
        if core_remaining <= 0:
            reset_timestamp = calendar.timegm(rl_core.reset.timetuple())
            sleep_time = reset_timestamp - calendar.timegm(time.gmtime()) + 5
            print("API rate limit exceded: " + str(sleep_time) + " sleep_time. Waiting...")
            time.sleep(sleep_time)
            g = authenticate()
    except:
        aux.printLog("Error al aplicar el control del API rate limit exceded...", logging.ERROR)
\end{lstlisting}

- La API de GitLab, al igual que la API de GitHub, cuenta con limitaciones a la hora de realizar llamadas sobre ella. En este caso no se limitan el número de peticiones sobre la API, sino que se limitan el número de proyectos que se pueden obtener.

Cada consulta a la API de GitLab cuenta con un número de páginas y en cada página un número X de proyectos, siendo X de 20 a 100 proyectos en función de lo que se configure en la variable ``per\_page'' de la consulta. 

Para tratar los repositorios devueltos por una consulta se pueden ir recorriendo las páginas que la conforman y por cada página se pueden ir tratando los repositorios contenidos. Sin embargo, al alcanzar al repositorio número 20.001 del recorrido se lanza la excepción correspondiente a la limitación de GitLab.

\alumno{No se ve bien la excepción. Revisar.}
\textit{gitlab.exceptions.GitlabHttpError: 405: Offset pagination has a maximum allowed offset of 50000 for requests that return objects of type Project. Remaining records can be retrieved using keyset pagination.}

La solución empleada para corregir este problema es la siguiente: en lugar de realizar una única consulta e ir recorriendo las páginas y repositorios de esa única consulta, se generan varias consultas en serie, siempre recorriendo el número máximo de repositorios devueltos en la primera página. Una vez ya han sido los repositorios correspondientes a la primera página de la consulta lanzada, se lanza otra consulta distinta partiendo del identificador del último repositorio tratado en la consulta anterior. De esta forma se puede esquivar la limitación de 20.000 repositorios por consulta impuesta por la API de GitLab e ir obteniendo infinitos proyectos.

- La librería PyYaml permite transformar un fichero con formato YML en un diccionario Python en formato json. Tras ejecutar el proceso de análisis de repositorios de forma masiva se han encontrado casos en los que el fichero YML de configuración del sistema de CI empleado para automatizar trabajos no estaba bien construido, provocando que esta librería no pudiese realizar la conversión de forma satisfactoria, lanzando excepciones similares a la que se muestra a continuación:

\alumno{No se ve bien la excepción. Revisar.}
\textit{while scanning a quoted scalar in ``tmp/ftmp\_0.yml'', line 21, column 27 found unexpected end of stream in ``tmp/ftmp\_0.yml'', line 22, column 1}

- Otro problema relacionados con la API de GitLab es la escasez de filtros que se pueden aplicar sobre cada consulta. A diferencia de la API de GitHub, la de GitLab no permite filtrar por lenguaje o número de estrellas dando lugar a que se tengan que ir comprobando uno a uno mediante los atributos ``language'' y ``stars'' de los objetos ``project''. Esto ha supuesto que el proceso de ejecución sobre proyectos GitLab tarde más en ejecutarse que la ejecución sobre repositorios GitHub.