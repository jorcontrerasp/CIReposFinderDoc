Para llevar a cabo este estudio se implementa una programa encargado de aplicar el heurístico desarrollado sobre los repositorios alojados tanto en GitHub como en GitLab.

\section{Herramientas utilizadas}
Las herramientas que se han utilizado para elaborar el programa son las siguientes:
\subsection{Python}
Es un lenguaje de programación cuya filosofía hace hincapié en la legibilidad del código. Sus principales características son las siguientes:
\begin{compactitem}
    \item Multiparadigma: ya que más que forzar a los programadores a adoptar un estilo de programación, permite varios estilos, soportando la orientación a objetos, la programación imperativa y la funcional.
    \item Interpretado.
    \item Dinámico: permitiendo que una variable pueda tomar valores de distinto tipo.
    \item Multiplataforma.
\end{compactitem}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.3\textwidth,clip=true]{\logoPython}
    \caption{Logo de Python.}
\end{figure}

\subsection{API de GitHub}
API REST que nos va a permitir utilizar diferentes métodos para obtener información acerca de los repositorios almacenados en GitHub.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.2\textwidth,clip=true]{\logoGitHub}
    \caption{Logo de GitHub.}
\end{figure}

\subsection{API de GitLab}
API REST que nos va a permitir utilizar diferentes métodos para obtener información acerca de los repositorios almacenados en GitLab.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth,clip=true]{\logoGitLab}
    \caption{Logo de GitLab.}
\end{figure}

\subsection{Visual Studio Code}
Visual Studio Code es un editor de código fuente ligero pero potente que se ejecuta en su escritorio y está disponible para Windows, macOS y Linux. Viene con soporte incorporado para JavaScript, TypeScript y Node.js y tiene un rico ecosistema de extensiones para otros lenguajes  (como C++, Java, Python, PHP o Go) y tiempos de ejecución (como .NET y Unity).
En este trabajo se va a utilizar tanto para la implementación del programa en python que se va a utilizar para obtener información sobre integración continua como para la escritura de la memoria final en LaTeX.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.3\textwidth,clip=true]{\logoVscode}
    \caption{Logo de Visual Studio Code.}
\end{figure}

\section{Implementación Python}

\subsection{Ficheros Python}
La implementación del programa buscador de repositorios que utilizan herramientas de integración continua cuenta con los siguientes ficheros:
\begin{compactitem}
    \item \textbf{aux\_functions.py}: script de python que contiene funciones auxiliares en las que se apoyará el programa principal.
    \item \textbf{ci\_tools.py}: script en el que se definen todas las herramientas de integración que se van a buscar en el proceso junto con la forma en la que se van a encontrar dichas herramientas, es decir, contiene las instrucciones que conforman el heurístico de búsqueda.
    \item \textbf{ci\_yml\_parser.py}: script que transforma las instrucciones de un fichero YML a objetos Python con el objetivo de que sean tratados  de forma más trivial al devolver la información que contengan.
    \item \textbf{config.yml}: fichero en el que se definen todas las variables de configuración del proceso de búsqueda.
    \item \textbf{dataF\_functions.py}: script contenedor de todas las funciones relacionadas con la gestión de la estructura de datos utilizada ``DataFrame'' para generar la información de retorno.
    \item \textbf{github\_queryMaker.py}: script que permite construir consultas con el formato aceptado por la API de GitHub.
    \item \textbf{github\_search.py}: script en el que se realiza la búsqueda de repositorios GitHub.
    \item \textbf{github\_tests.py}: script utilizado para aplicar el heurístico sobre un repositorio GitHub concreto, es decir, permite realizar pruebas unitarias sobre repositorios GitHub.
    \item \textbf{gitlab\_search.py}: script en el que se realiza la búsqueda de repositorios GitLab.
    \item \textbf{gitlab\_tests.py}: script utilizado para aplicar el heurístico sobre un repositorio GitLab concreto, es decir, permite realizar pruebas unitarias sobre repositorios GitLab.
    \item \textbf{main.py}: script que se llaman a todos las funciones necesarias para realizar el proceso de búqueda de repositorios. Conforma el programa principal.
    \item \textbf{project\_cleaner.py}: script que va a permitir limpiar el proyectos de ficheros que ya no sirvan (fiocheros de xlsx de resultados, ficheros pickle y ficheros de log).
    \item \textbf{convertExcel2LaTeXr.py}: script que va a permitir convertir las tablas de los ficheros excel de resultados en código fuente LaTeX con el objetivo de facilitar la escritura de las mismas en la memoria del trabajo.
\end{compactitem}

Este proceso encargado de aplicar el heurístico de búsqueda de repositorios con CI se ha programado de tal forma que sea configurable mediante el fichero ``config.yml''. Este fichero de configuración cuenta con tres partes bien diferenciadas:

\begin{enumerate}
    \item \textbf{``process''} con variables relacionadas con la configuración del proceso genérico.
    \begin{compactitem}
        \item \textbf{``execute''}: indica si se ejecuta o no el proceso en su totalidad.
        \item \textbf{``doGithubSearch''}: indica si se ejecuta o no la búsqueda sobre repositorios GitHub.
        \item \textbf{``doGitlabSearch''}: indica si se ejecuta o no la búsqueda sobre proyectos GitLab.
        \item \textbf{``usePickleFile''}: indica si se utiliza o no un fichero binario de Python con extensión ``.pickle'' para obtener los repositorios, que fueron recuperados previamente en una búsqueda anterior, a los que se les aplicará el heurístico.
        \item \textbf{``useResultsExcelFile''}: indica si se continúa rellenando un fichero de resultados excel ya existente.
        \item \textbf{``tmpDirectory''}: variable que almacena el directorio de ficheros temporales.
        \item \textbf{``tmpFile''}: variable que almacena el nombre d eun fichero temporal.
    \end{compactitem}
    \item \textbf{``github''} con variables relacionadas con la configuración de la búsqueda GitHub.
    \begin{compactitem}
        \item \textbf{``queryFile''}: indica qué consulta es la que se va a utilizar en la búsqueda sobre repositorios GitHub.
        \item \textbf{``filterCommits''}: indica si se filtra o no por los commits.
        \item \textbf{``MAX\_COMMITS''}: en el caso de filtrar por cómmits, indica el número máximo de commits que tendrán los repositorios.
        \item \textbf{``MIN\_COMMITS''}: en el caso de filtrar por cómmits, indica el número mínimo de commits que tendrán los repositorios.
        \item \textbf{``randomizeRepos''}: indica si se obtienen ``n'' repositorios aleatorios de la lista inicial de repositorios obtenida para aplicar el heurístico.
        \item \textbf{``N\_RANDOM''}: indica, en el caso de que se marque la opción ``randomizeRepos'', el número de repositorios aleatorios que se obtendrán.
        \item \textbf{``onlyPositives''}: indica si se devuelven única y exclusivamente repositorios positivos en los ficheros de resultados.
    \end{compactitem}
    \item \textbf{``gitlab''} con variables relacionadas con la configuración de la búsqueda GitLab.
    \begin{compactitem}
        \item \textbf{``search1By1''}: indica si se aplicará el heurístico a cada proyecto según se vayan encontrando o si, por el contrario, se obtienen todos los proyectos y a continuación, una vez obtenidos, se recorren para aplicarles el heurístico. Si buscamos solo positivos, search1By1 será True sí o sí (se controla por programa), da igual lo que venga en el fichero de configuración.
        \item \textbf{``N\_ERROR\_PAGE\_ATTEMPTS''}: indica el número máximo de intentos en caso de que la llamada a la API de GitLab falle.
        \item \textbf{``LANGUAGE''}: indica el lenguaje en el que tendrán que estar implementados los proyectos GitLab analizados.
        \item \textbf{``N\_MAX\_SEARCHES''}: indica el número máximo de búsquedas que se van a realizar.
        \item \textbf{``N\_MIN\_STARS''}: indica el número mínimo de estrellas que tendrán que tener los proyectos GitLab analizados.
        \item \textbf{``onlyPositives''}: indica si se devuelven única y exclusivamente proyectos positivos en los ficheros de resultados.
        \item \textbf{``N\_MAX\_PROJECTS''}: si solo buscamos positivos, N\_MAX\_PROJECTS será el nº máximo de positivos a encontrar. Si buscamos tanto positivos como negativos, N\_MAX\_PROJECTS será el número máximo de projectos que tratará (sean o no positivos en CI).
    \end{compactitem}
\end{enumerate}

\subsection{Librerías utilizadas}
Las librerías utilizadas para la implementación del programa son las siguientes:
\begin{compactitem}
    \item \textbf{PyGithub}: librería que facilita el uso de la API de GitHub v3. Permite la gestión de diferentes recursos de GitHub (repositorios, perfiles de usuario, organizaciones, etc.) desde scripts Python.
    \item \textbf{Python-Gitlab}: librería que facilita el uso de la API v4 de GitLab y proporciona una herramienta CLI. Permite la gestión de diferentes recursos sobre proyectos almacenados en GitLab desde scripts Python.
    \item \textbf{Pandas}: iniciada en 2008, es una librería que pretende ser el bloque de construcción fundamental de alto nivel para realizar análisis de datos prácticos del mundo real en Python. Además, tiene el objetivo más amplio de convertirse en la herramienta de análisis/manipulación de datos de código abierto más potente y flexible disponible en cualquier idioma. Nos va a permitir manejar DataFrames y convertir la información que queramos tanto en formato excel como en formato csv para su posterior estudio.
    \item \textbf{Pickle}: importando esta librería en el proyecto vamos a poder almacenar la información que queramos en un fichero binario de Python. En este caso, una vez obtenidos los repositorios a analizar se almacenarán en un fichero de este tipo para poder reutilizar esos repositorios en posteriores ejecuciones.
    \item \textbf{Base64}: este módulo proporciona funciones para codificar datos binarios en caracteres ASCII imprimibles y decodificar dichas codificaciones en datos binarios.
    \item \textbf{PyYaml}: PyYAML es un marco YAML con todas las funciones para el lenguaje de programación Python. Nos va a permitir transformar ficheros con extensión YAML o YML en diccionarios Python en formato JSON.
    \item \textbf{Shutil}: librería que, mediante la instrucción ``rmtree'' va a permitir borrar carpetas de ficheros temporales utilizados para analizar cada repositorio GitHub/GitLab.
    \item \textbf{Json}: librería que va a permitir transformar textos en formato json en un objeto diccionario de Python.
\end{compactitem}

\subsection{Ficheros resultantes}
El proceso de búsqueda de herramientas de integración continua va a generar varios ficheros en local con información que va a permitir alimentar de contenido el estudio y análisis de estas herramientas. Estos ficheros son:
\begin{compactitem}
    \item \textbf{github/github\_results.xlsx}: Fichero excel que va a componer una matriz repositorio de GitHub/herramienta de CI indicando en su intersección mediante una ``X'' si es o no positivo.
    \item \textbf{github/github\_languages.xlsx}: Fichero excel que va a componer una matriz lenguaje (de los repositorios GitHub encontrados)/herramienta de CI indicando el número de repositorios positivos en el lenguaje X y la herramienta de CI Y.
    \item \textbf{github/github\_ci\_statistics.xlsx}: Fichero excel en el que se van a recoger, por cada sistema de ci, datos estadísticos como el mínimo, el máximo, la media y la mediana relativos a la búsqueda sobre repositorios GitHub.
    \item \textbf{github/github\_language\_statistics.xlsx}: Fichero excel en el que se van a recoger, por cada lenguaje de programación encontrado, datos estadísticos como el mínimo, el máximo, la media y la mediana relativos a la búsqueda sobre repositorios GitHub.
    \item \textbf{github/github\_stage\_statistics.xlsx}: Fichero excel en el que se van a ir almacenando los contadores de los ``stages'' encontrados en el proceso de búsqueda GitHub.
    \item \textbf{repos\_github.pickle}: Fichero binario de Python en el que se van a almacenar los repositorios GitHub utilizados a la hora de aplicar el heurístico.
    \item \textbf{gitlab/gitlab\_results.xlsx}: Fichero excel que va a componer una matriz repositorio de GitLab/herramienta de CI indicando en su intersección mediante una ``X'' si es o no positivo.
    \item \textbf{gitlab/gitlab\_languages.xlsx}: Fichero excel que va a componer una matriz lenguaje (de los repositorios GitLab encontrados)/herramienta de CI indicando el número de repositorios positivos en el lenguaje X y la herramienta de CI Y.
    \item \textbf{gitlab/gitlab\_ci\_statistics.xlsx}: Fichero excel en el que se van a recoger, por cada sistema de ci, datos estadísticos como el mínimo, el máximo, la media y la mediana relativos a la búsqueda sobre repositorios GitLab.
    \item \textbf{gitlab/gitlab\_language\_statistics.xlsx}: Fichero excel en el que se van a recoger, por cada lenguaje de programación encontrado, datos estadísticos como el mínimo, el máximo, la media y la mediana relativos a la búsqueda sobre repositorios GitLab.
    \item \textbf{gitlab/gitlab\_stage\_statistics.xlsx}: Fichero excel en el que se van a ir almacenando los contadores de los ``stages'' encontrados en el proceso de búsqueda GitLab.
    \item \textbf{repos\_gitlab.pickle}: Fichero binario de Python en el que se van a almacenar los repositorios GitLab utilizados a la hora de aplicar el heurístico.
    \item \textbf{counting.xlsx}: Fichero excel con un conteo de los excel de resultados tanto en GitHub como en GitLab a modo de resumen.
\end{compactitem}

\section{Proceso de ejecución}
La implementación del programa está dividida en dos partes bien diferenciadas: una encargada de ejecutar el proceso sobre repositorios GitHub y la otra sobre repositorios GitLab. En cada parte se utilizará para su cometido la API correspondiente a los repositorios a los que se les está aplicando el proceso de búsqueda.

En primer lugar se comprueba mediante la variable ``execute'' si se desea ejecutar o no el proceso en su totalidad. En el caso de que dicha variable sea afirmativa se iniciará el proceso generando las estructuras de datos necesarias que se irán completando con datos obtenidos por la búsqueda. 

Estas estructuras de datos necesarias serían el ``dataframe'' de resultados, el de lenguajes y el de contadores, las cuales podrán ser generadas de cero o recuperadas a partir de ficheros excel ya generados con anterioridad en función de la variable de configuración ``useResultsExcelFile''.

A continuación el programa prosigue ejecutando el proceso de búsqueda sobre GitHub y a continuación sobre GitLab, siempre y cuando las variables ``doGitHubSearch'' y ``doGitLabSearch'' respectivamente sean positivas.

En cuanto a la parte de ejecución sobre repositorios de la plataforma GitHub, en primer lugar se cargará la lista de repositorios que va a ser utilizada para aplicar el heurístico. Esta podrá ser obtenida mediante la carga desde un fichero binario de Python con extensión ``.pickle'' o podrá ser obtenida desde cero mediante una llamada a la API de GitHub.

Una vez obtenida la lista de repositorios se aplicará el heurístico sobre cada uno de los repositorios que la conforman y se irán rellenando los dataframes que serán devueltos finalmente en formato excel en aras de ser comprendido de forma trivial.

En cuanto a la parte correspondiente a la ejecución sobre proyectos GitLab, al igual que en la parte de GitHub ya mencionada, se podrán obtener los repositorios cargados desde un fichero binario de python con extensión ``.pickle'' o se podrán generar mediante la llamada a la API de GitLab. En el caso de que se tenga que llamar a la API de GitLab para generar los repositorios, se diferencian dos formas de actuar en función de la variable de configuración ``search1By1'': obteniendo los repositorios y aplicar el heurístico a la lista que se genere, o ir aplicando el heurístico uno a uno según se vaya cargando la lista de repositorios.

Finalmente, se transformarán las variables del tipo DataFrame proporcionadas por la librería ``Pandas'' en formato Excel o Csv.

A modo de resumen, se expone a continuación el flujo de ejecución del programa:

\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth,clip=true]{\flujoGitHub}
    \caption{Flujo de ejecución GitHub.}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=1.25\textwidth,clip=true]{\flujoGitLab}
    \caption{Flujo de ejecución GitLab.}
\end{figure}

\section{Dificultades y problemas encontrados}
En la realización de este trabajo se han ido encontrando diferentes errores que suponían un impedimento a la hora de continuar. Los más comunes han sido los siguientes:
- Resulta que la API de GitHub nos permite crear llamadas para obtener información sobre los diferentes repositorios que contiene, y de esta manera poder integrar nuestra aplicación con GitHub, pero con una limitación de 60 peticiones a la hora, número insuficiente para realizar una búsqueda masiva que devuelva una cantidad aceptable de repositorios con la que poder llevar a cabo el estudio de manera objetiva. En el momento en el que se utilizan más de los que esta API puede tratar se lanza la siguiente excepción: 

\alumno{No se ve bien la excepción. Revisar.}
\textit{github.GithubException.RateLimitExceededException: 403 \{``message'': ``API rate limit exceeded for user ID 77851630.'', ``documentation\_url'': ``https://docs.github.com/rest/overview/resources-in-the-rest-api\#rate-limiting''\}}

Generando un token de autenticación podemos incrementar el número de peticiones por hora DE 60 A 5000 [AÑADIR ANEXO DE GENERACIÓN DE TOKEN GITHUB]. Sin embargo, este número incrementado de peticiones sigue siendo insuficiente para poder ejecutar el proceso de forma masiva sobre una gran cantidad de repositorios.
La solución empleada para corregir este problema es la siguiente: maediante la función ``get-rate-limit()'' de la API de GitHub, antes de gastar una consulta se obtendrá el número de peticiones restantes y al llegar al límite se pausará el proceso hasta que pase el tiempo necesario para recuperar dichas peticiones. Una vez recuperadas las peticiones se proseguirá con la ejecución.

\begin{lstlisting}[language=Python, caption=Control del nº de peticiones a la API GitHub, label={lst:ejem1}]
def doApiRateLimitControl():
    try:
        g = authenticate()
        rl = g.get_rate_limit()
        rl_core = rl.core
        core_remaining = rl_core.remaining
        rl_search = rl.search
        search_remaining = rl_search.remaining
        if core_remaining <= 0:
            reset_timestamp = calendar.timegm(rl_core.reset.timetuple())
            sleep_time = reset_timestamp - calendar.timegm(time.gmtime()) + 5
            print("API rate limit exceded: " + str(sleep_time) + " sleep_time. Waiting...")
            time.sleep(sleep_time)
            g = authenticate()
    except:
        aux.printLog("Error al aplicar el control del API rate limit exceded...", logging.ERROR)
\end{lstlisting}
\cotutor{Si usas este fragmento de código, en lugar de decir 'A continuación ...' debes referenciar al 'listing' en este caso, usando Listing~\ref{lst:ejem1} (Ver código fuente)}

- La API de GitLab: al igual que la API de GitHub, la API de GitLab cuenta con una limitaciones a la hora de realizar llamadas sobre la misma. En este caso no se limitan el número de peticiones sobre la API, sino que se limitan el número de proyectos que se pueden obtener.
Cada consulta a la API de GitLab cuanta con un número de páginas y en cada página un número X de proyectos, siendo X de 20 a 100 proyectos en función de lo que se configure en la variable XXXXX de la consulta. Para tratar los repositorios devueltos por la consulta se tienen que recorrer dichas páginas y por cada página los repositorios devueltos. Sin embargo, al llegar al repositorio número 20.001 se lanza la excepción correspondiente a la limitación de GitLab.

\alumno{No se ve bien la excepción. Revisar.}
\textit{gitlab.exceptions.GitlabHttpError: 405: Offset pagination has a maximum allowed offset of 50000 for requests that return objects of type Project. Remaining records can be retrieved using keyset pagination.}

La solución empleada para corregir este problema es la siguiente: en lugar de realizar una única consulta e ir recorriendo las páginas y repositorios de esa única consulta, se irán generando varias consultas en serie, siempre recorriendo el número máximo de repositorios que se devuelven en la página 1. Una vez terminado de obtener los repositorios correspondientes a la página 1 de la consulta lanzada, se lanza la siguiente consulta partiendo del identificador del último repositorio tratado en la anterior consulta. De esta forma se podrá esquivar la limitación de 20.000 repositorios por consulta impuesta por la API de GitLab e ir obteniendo infinitos proyectos.

- La librería PyYaml permite transformar un fichero con formato YML en un diccionario Python en formato JSON. Tras ejecutar el proceso de análisis de repositorios de forma masiva se han encontrado casos en los que el fichero YML de configuración del sistema de CI empleado para automatizar trabajos no estaba bien construido, provocando que esta librería no pudiese realizar la conversión de forma satisfactoria, lanzando excepciones similares a la que se muestra a continuación:

\alumno{No se ve bien la excepción. Revisar.}
\textit{while scanning a quoted scalar in ``tmp/ftmp\_0.yml'', line 21, column 27 found unexpected end of stream in ``tmp/ftmp\_0.yml'', line 22, column 1}

- Otros problemas relacionados con la API de GitLab es la escasez de filtros que se pueden aplicar sobre cada consulta, a diferencia de la API de GitHub, la de GitLab no permite filtrar por lenguaje o número de estrellas dando lugar a que se tengan que ir comprobando uno a uno mediante los atributos 'language' y 'stars' de los objetos 'project'. Esto ha supuesto que el proceso de ejecución sobre proyectos GitLab tarde más en ejecutarse que la ejecución sobre repositorios GitHub.