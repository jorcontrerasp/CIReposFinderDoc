Para llevar a cabo este estudio se implementa una programa encargado de aplicar el heurístico desarrollado sobre los repositorios alojados tanto en GitHub como en GitLab.

\section{Herramientas utilizadas}
Las herramientas que se han utilizado para elaborar el programa son las siguientes:
\subsection{Python}
Es un lenguaje de programación cuya filosofía hace hincapié en la legibilidad del código. Sus principales características son las siguientes:
\begin{enumerate}
    \item Multiparadigma: ya que más que forzar a los programadores a adoptar un estilo de programación, permite varios estilos, soportando la orientación a objetos, la programación imperativa y la funcional.
    \item Interpretado.
    \item Dinámico: permitiendo que una variable pueda tomar valores de distinto tipo.
    \item Multiplataforma.
\end{enumerate}

\subsection{API de GitHub}
API REST que nos va a permitir utilizar diferentes métodos para obtener información acerca de los repositorios almacenados en GitHub.

\subsection{API de GitLab}
API REST que nos va a permitir utilizar diferentes métodos para obtener información acerca de los repositorios almacenados en GitLab.

\subsection{Visual Studio Code}
Visual Studio Code es un editor de código fuente ligero pero potente que se ejecuta en su escritorio y está disponible para Windows, macOS y Linux. Viene con soporte incorporado para JavaScript, TypeScript y Node.js y tiene un rico ecosistema de extensiones para otros lenguajes  (como C++, Java, Python, PHP o Go) y tiempos de ejecución (como .NET y Unity).
En este trabajo se va a utilizar tanto para la implementación del programa en python que se va a utilizar para obtener información sobre integración continua como para la escritura de la memoria final en LaTeX.

\section{Implementación Python}

\subsection{Ficheros Python}
La implementación del programa buscador de repositorios que utilizan herramientas de integración continua cuenta con los siguientes ficheros:
\begin{enumerate}
    \item aux-functions.py: script de python que contiene funciones auxiliares en las que se apoyará el programa principal.
    \item ci-tools.py: script en el que se definen todas las herramientas de integración que se van a buscar en el proceso junto con la forma en la que se van a encontrar dichas herramientas, es decir, contiene las instrucciones que conforman el heurístico de búsqueda.
    \item ci-yml-parser.py: script que transforma las instrucciones de un fichero YML a objetos Python con el objetivo de que sean tratados  de forma más trivial al devolver la información que contengan.
    \item config.yml: fichero en el que se definen todas las variables de configuración del proceso de búsqueda.
    \item dataF-functions.py: script contenedor de todas las funciones relacionadas con la gestión de la estructura de datos utilizada "DataFrame" para generar la información de retorno.
    \item github-queryMaker.py: script que permite construir consultas con el formato aceptado por la API de GitHub.
    \item github-search.py: script en el que se realiza la búsqueda de repositorios GitHub.
    \item github-tests.py: script utilizado para aplicar el heurístico sobre un repositorio GitHub concreto, es decir, permite realizar pruebas unitarias sobre repositorios GitHub.
    \item gitlab-search.py: script en el que se realiza la búsqueda de repositorios GitLab.
    \item gitlab-tests.py: script utilizado para aplicar el heurístico sobre un repositorio GitLab concreto, es decir, permite realizar pruebas unitarias sobre repositorios GitLab.
    \item main.py: script que se llaman a todos las funciones necesarias para realizar el proceso de búqueda de repositorios. Conforma el programa principal.
\end{enumerate}

\subsection{Librerías utilizadas}
Las librerías utilizadas para la implementación del programa son las siguientes:
\begin{enumerate}
    \item PyGithub: librería que facilita el uso de la API de GitHub v3. Permite la gestión de diferentes recursos de GitHub (repositorios, perfiles de usuario, organizaciones, etc.) desde scripts de Python.
    \item PyGitlab:
    \item Pandas: iniciada en 2008, es una librería que pretende ser el bloque de construcción fundamental de alto nivel para realizar análisis de datos prácticos del mundo real en Python. Además, tiene el objetivo más amplio de convertirse en la herramienta de análisis/manipulación de datos de código abierto más potente y flexible disponible en cualquier idioma. Nos va a permitir manejar DataFrames y convertir la información que queramos tanto en formato excel como en formato csv para su posterior estudio.
    \item Pickle: importando esta librería en el proyecto vamos a poder almacenar la información que queramos en un fichero binario de Python. En este caso, una vez obtenidos los repositorios a analizar se almacenarán en un fichero de este tipo para poder reutilizar esos repositorios en posteriores ejecuciones.
    \item Base64: este módulo proporciona funciones para codificar datos binarios en caracteres ASCII imprimibles y decodificar dichas codificaciones en datos binarios.
\end{enumerate}

\subsection{Ficheros resultantes}
El proceso de búsqueda de herramientas de integración continua va a generar varios ficheros en local con información que va a permitir alimentar de contenido el estudio y análisis de estas herramientas. Estos ficheros son:
\begin{enumerate}
    \item resultados-github.xlsx: Fichero excel que va a componer una matriz repositorio de GitHub/herramienta de CI indicando en su intersección mediante una "X" si es o no positivo.
    \item lenguajes-github.xlsx: Fichero excel que va a componer una matriz lenguaje (de los repositorios GitHub encontrados)/herramienta de CI indicando el número de repositorios positivos en el lenguaje X y la herramienta de CI Y.
    \item repos-github.pickle: Fichero binario de Python en el que se van a almacenar los repositorios GitHub utilizados a la hora de aplicar el heurístico.
    \item resultados-gitlab.xlsx: Fichero excel que va a componer una matriz repositorio de GitLab/herramienta de CI indicando en su intersección mediante una "X" si es o no positivo.
    \item lenguajes-gitlab.xlsx: Fichero excel que va a componer una matriz lenguaje (de los repositorios GitLab encontrados)/herramienta de CI indicando el número de repositorios positivos en el lenguaje X y la herramienta de CI Y.
    \item repos-gitlab.pickle: Fichero binario de Python en el que se van a almacenar los repositorios GitLab utilizados a la hora de aplicar el heurístico.
    \item contadores.xlsx: Fichero excel con un conteo de los excel de resultados tanto en GitHub como en GitLab a modo de resumen.
\end{enumerate}

\section{Proceso de ejecución}
La implementación del programa está dividida en dos partes bien diferenciadas: una encargada de ejecutar el proceso sobre repositorios GitHub y la otra sobre repositorios GitLab. En cada parte se utilizará para su cometido la API correspondiente a los repositorios a los que se les está aplicando el proceso de búsqueda.
En primer lugar se comprueba mediante la variable 'execute' si se desea ejecutar o no el proceso en su totalidad. En el caso de que dicha variable sea afirmativa se iniciará el proceso generando las estructuras de datos necesarias que se irán completando con datos obtenidos por la búsqueda. 
Estas estructuras de datos necesarias serían el 'dataframe' de resultados, el de lenguajes y el de contadores, las cuales podrán ser generadas de cero o recuperadas a partir de ficheros excel ya generados con anterioridad en función de la variable de configuración 'useResultsExcelFile'.
A continuación el programa prosigue ejecutando el proceso de búsqueda sobre GitHub y a continuación sobre GitLab, siempre y cuando las variables 'doGitHubSearch' y 'doGitLabSearch' respectivamente sean positivas.
En cuanto a la parte de ejecución sobre repositorios de la plataforma GitHub, en primer lugar se cargará la lista de repositorios que va a ser utilizada para aplicar el heurístico. Esta podrá ser obtenida mediante la carga desde un fichero binario de Python con extensión '.pickle' o podrá ser obtenida desde cero mediante una llamada a la API de GitHub.
Una vez obtenida la lista de repositorios se aplicará el heurístico sobre cada uno de los repositorios que la conforman y se irán rellenando los dataframes que serán devueltos finalmente en formato excel en aras de ser comprendido de forma trivial.
En cuanto a la parte correspondiente a la ejecución sobre proyectos GitLab, al igual que en la parte de GitHub ya mencionada, se podrán obtener los repositorios cargados desde un fichero binario de python con extensión '.pickle' o se podrán generar mediante la llamada a la API de GitLab. En el caso de que se tenga que llamar a la API de GitLab para generar los repositorios, se diferencian dos formas de actuar en función de la variable de configuración 'search1By1': obteniendo los repositorios y aplicar el heurístico a la lista que se genere, o ir aplicando el heurístico uno a uno según se vaya cargando la lista de repositorios.
Finalmente, se transformarán las variables del tipo DataFrame proporcionadas por la librería 'Pandas' en formato Excel o Csv.
A modo de resumen, se expone a continuación el flujo de ejecución del programa:

\begin{figure}
    \centering
    \includegraphics[width=1\textwidth,clip=true]{\flujoEjecucion}
    \caption{Flujo de ejecución.}
\end{figure}

\alumno{¿Posición de la figura?}

\section{Dificultades y problemas encontrados}
En la realización de este trabajo se han ido encontrando diferentes errores que suponían un impedimento a la hora de continuar. Los más comunes han sido los siguientes:
- Resulta que la API de GitHub nos permite crear llamadas para obtener información sobre los diferentes repositorios que contiene, y de esta manera poder integrar nuestra aplicación con GitHub, pero con una limitación de 60 peticiones a la hora, número insuficiente para realizar una búsqueda masiva que devuelva una cantidad aceptable de repositorios con la que poder llevar a cabo el estudio de manera objetiva. En el momento en el que se utilizan más de los que esta API puede tratar se lanza la siguiente excepción: 

-EXCEPCIÓN-

Generando un token de autenticación podemos incrementar el número de peticiones por hora DE 60 A 5000 [AÑADIR ANEXO DE GENERACIÓN DE TOKEN GITHUB]. Sin embargo, este número incrementado de peticiones sigue siendo insuficiente para poder ejecutar el proceso de forma masiva sobre una gran cantidad de repositorios.
La solución empleada para corregir este problema es la siguiente: maediante la función 'get-rate-limit()' de la API de GitHub, antes de gastar una consulta se obtendrá el número de peticiones restantes y al llegar al límite se pausará el proceso hasta que pase el tiempo necesario para recuperar dichas peticiones. Una vez recuperadas las peticiones se proseguirá con la ejecución.

'def getContents(repo, path):
    contents = None
    g = authenticate()
    rl = g.get-rate-limit()
    rl-core = rl.core
    core-remaining = rl-core.remaining
    rl-search = rl.search
    search-remaining = rl-search.remaining
    if core-remaining <= 0:
        reset-timestamp = calendar.timegm(rl-core.reset.timetuple())
        sleep-time = reset-timestamp - calendar.timegm(time.gmtime()) + 5
        print("API rate limit exceded: " + str(sleep-time) + " sleep-time. Waiting...")
        time.sleep(sleep-time)
        g = authenticate()

    contents = repo.get-contents(path)
    return contents'

\alumno{¿Formato de la función en Python?}\\
\alumno{¿Cómo escapar guión bajo en LaTeX?}
	
- La API de GitLab: al igual que la API de GitHub, la API de GitLab cuenta con una limitaciones a la hora de realizar llamadas sobre la misma. En este caso no se limitan el número de peticiones sobre la API, sino que se limitan el número de proyectos que se pueden obtener.
Cada consulta a la API de GitLab cuanta con un número de páginas y en cada página un número X de proyectos, siendo X de 20 a 100 proyectos en función de lo que se configure en la variable XXXXX de la consulta. Para tratar los repositorios devueltos por la consulta se tienen que recorrer dichas páginas y por cada página los repositorios devueltos. Sin embargo, al llegar al repositorio número 20.001 se lanza la excepción correspondiente a la limitación de GitLab.

-EXCEPCIÓN-

La solución empleada para corregir este problema es la siguiente: en lugar de realizar una única consulta e ir recorriendo las páginas y repositorios de esa única consulta, se irán generando varias consultas en serie, siempre recorriendo el número máximo de repositorios que se devuelven en la página 1. Una vez terminado de obtener los repositorios correspondientes a la página 1 de la consulta lanzada, se lanza la siguiente consulta partiendo del identificador del último repositorio tratado en la anterior consulta. De esta forma se podrá esquivar la limitación de 20.000 repositorios por consulta impuesta por la API de GitLab e ir obteniendo infinitos proyectos.

- Otros problemas relacionados con la API de GitLab es la escasez de filtros que se pueden aplicar sobre cada consulta, a diferencia de la API de GitHub, la de GitLab no permite filtrar por lenguaje o número de estrellas dando lugar a que se tengan que ir comprobando uno a uno mediante los atributos 'language' y 'stars' de los objetos 'project'. Esto ha supuesto que el proceso de ejecución sobre proyectos GitLab tarde más en ejecutarse que la ejecución sobre repositorios GitHub.