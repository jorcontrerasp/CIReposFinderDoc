\section{Contexto y alcance}

Actualmente, tareas aparentemente fundamentales como las pruebas, revisiones de código o compilaciones frecuentes de software deben ser difíciles de llevar a cabo debido a que la frecuencia de uso en proyectos software es miserablemente baja.
Si se desean ``builds'' de integración para que no se convierta en un evento esporádico en el proyecto que se esté implementando, incluyendo la compilación, reconstrucción de bases de datos, ejecución de pruebas automatizadas, el despliegue del software y la obtención de “feedback”, la integración continua o CI puede ayudar.

La integración continua o CI es una práctica de desarrollo de software mediante la cual los desarrolladores combinan los cambios de código en un repositorio central de forma periódica, permitiendo la ejecución de versiones y la realización de pruebas automáticas sobre las mismas. Es decir, CI como proceso significa que cada cambio subido a un sistema de control de versiones ha sido puesto a prueba, validado y aceptado.

En aras de comprender lo que engloba la integración continua cabría definir también conceptos como “build” o escenario CI: un “build” es mucho más que una compilación, también engloba el proceso de pruebas, inspección de código y despliegue del mismo, a parte de otras cosas. Actúa como el proceso para juntar el código fuente y verificar que el software funcione como una unidad cohesiva. Un escenario de CI comienza cuando el desarrollador envía el código fuente al repositorio. En un proyecto típico, personas con diferentes roles pueden realizar cambios que desencadenan un ciclo de CI: los desarrolladores cambian el código fuente, los administradores de bases de datos (DBA) cambian las definiciones de las tablas, los equipos de desarrollo e implementación cambian los archivos de configuración, los equipos de interfaz cambian las especificaciones DTD/XSD y más.

Los pasos en un escenario de CI típicamente serán más o menos de la siguiente forma:
\begin{enumerate}
    \item Primero, un desarrollador envía código al repositorio de control de versiones. Mientras tanto, el servidor de CI en la máquina de compilación de integración sondea este repositorio en busca de cambios (cada pocos minutos, por ejemplo).
    \item Poco después de que se produzca una confirmación, el servidor de CI detecta que se han producido cambios en el repositorio de control de versiones, por lo que el servidor de CI recupera la última copia del código del repositorio y luego ejecuta un script de compilación, que integra el software.
    \item El servidor de CI genera comentarios enviando por correo electrónico los resultados de la compilación a los miembros del proyecto que se hayan especificados.
    \item El servidor de CI continúa buscando cambios en el depósito de control de versiones.
\end{enumerate}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.75\textwidth,clip=true]{\ciDiagram}
    \caption{Diagrama CI.}
\end{figure}

Anteriormente, era común que los desarrolladores de un equipo trabajasen aislados durante un largo periodo de tiempo y solo intentasen combinar los cambios en la versión final una vez completado el trabajo. Como consecuencia, la combinación de los cambios en el código resultaba ser una ardua tarea, dando lugar a que fuese más difícil proporcionar las actualizaciones a los clientes con rapidez.

Con la integración continua, los desarrolladores pueden enviar estos cambios de código de forma periódica a un repositorio compartido con un sistema de control de versiones como Git, y antes de cada envío, los desarrolladores pueden elegir ejecutar una serie de pruebas unitarias sobre el código como medida de verificación adicional antes de la integración.

Por lo tanto, los objetivos principales de la integración continua consisten en encontrar y arreglar errores con mayor rapidez, mejorar la calidad del software y reducir el tiempo que se tarda en validar y publicar nuevas actualizaciones del código fuente.

\section{Prerrequisitos de la integración continua}
Existen cuatro componentes requeridos para llevar a cabo el proceso de integración continua.
\begin{compactitem}
    \item Tener conexión a un sistema de control de versiones como por ejemplo git o subversion ``svn''.
    \item Tener un script de compilación ``build''.
    \item Tener algún tipo de mecanismo de retroalimentación, como una dirección de correo electrónico.
    \item Tener un proceso para integrar los cambios del código fuente (de forma manual o mediante un servidor de integración continua CI.
\end{compactitem}

\section{Subprocesos de la integración continua}
Mediante la integración continua y automática de bases de datos, pruebas, inspección de código, despliegue y ``feedback'' o retroalimentación, permite al sistema de CI reducir riesgos comunes del software generando una mayor confianza y comunicación sobre los diferentes cambios que se vayan a realizar y los errores que se puedan provocar con la incorporación de dichos cambios. 

Una vez que se ejecuta una compilación o ``build'' automatizada con cada cambio en el sistema de control de versiones, se pueden agregar otras funciones o subprocesos al sistema de CI. Algunas funciones dependen de otras; por ejemplo, las pruebas automatizadas dependen de la compilación del código fuente. Este proceso repetitivo puede ayudar a reducir riesgos a lo largo del ciclo de vida del desarrollo.

A continuación se describen más en detalle estos subprocesos.

\subsection{Compilación del código fuente}
La compilación continua de código fuente es una de las características más básicas y comunes de un sistema CI. De hecho, es tan común que casi se ha convertido en sinónimo de CI. La compilación implica la creación de un código ejecutable a partir de fuentes legibles. Sin embargo, CI es mucho más que compilación de código fuente.

\subsection{Integración de base de datos}
Hay personas que consideran la integración del código fuente y la integración de bases de datos como procesos completamente separados, siempre llevados a cabo por diferentes grupos. Esto es porque la base de datos es una parte integral de las aplicaciones software. 

Utilizando un sistema de integración continua se puede garantizar la integración de una base de datos a través de una única fuente: el repositorio de control de versiones. Para habilitar la integración continua de bases de datos en el proceso de construcción de un sistema de CI, tratamos el código fuente de la base de datos, las secuencias de comandos del ``Lenguaje de Definición de Datos'' (DDL), las secuencias de comandos del ``Lenguaje de Manipulación de Datos'' (DML), las definiciones de procedimientos almacenados, las particiones, etc. de la misma manera que cualquier otro código fuente del sistema. Por ejemplo, cuando un miembro del proyecto modifica un script de base de datos y lo confirma en el sistema de control de versiones, el mismo script de compilación que integra el código fuente reconstruirá la base de datos y los datos como parte del proceso de compilación.

\subsection{Pruebas o “testing”}
Se considera que la integración continua sin pruebas automatizadas no sería integración continua. Sin pruebas automatizadas, es difícil para los desarrolladores u otras partes interesadas del proyecto tener confianza en los cambios de software. La mayoría de los desarrolladores de proyectos que utilizan un sistema de CI usan herramientas de prueba unitaria como JUnit para ejecutar pruebas. Además, se pueden ejecutar diferentes categorías de pruebas desde un sistema de CI con el objetivo de acelerar el proceso de compilación. Estas categorías pueden incluir de unidad, componente, sistema, carga/rendimiento, seguridad y otros.

\subsection{Inspección de código}
Las inspecciones de código automatizadas se utilizan para mejorar la calidad del software al hacer cumplir ciertas reglas. Por ejemplo, un proyecto puede tener una regla de que ninguna clase puede tener más de 300 líneas de código sin comentarios. Utilizando un sistema de CI se pueden ejecutar estas reglas automáticamente contra una base de código.

\subsection{Despliegue}
El despliegue continuo permite entregar software funcional e implementable en cualquier momento. Esto significa que un propósito clave de un sistema de CI es generar los paquetes de artefactos software con los últimos cambios de código y ponerlos a disposición de un entorno de prueba. 

Entre otras cosas, se deben realizar las siguientes acciones en un proceso de despliegue:
\begin{compactitem}
    \item verificar los archivos fuente del repositorio de control de versiones, 
    \item realizar la compilación de los mismos, 
    \item todas las pruebas e inspecciones del código se deben ejecutar con éxito,
    \item etiquetar la versión
    \item y preparar los archivos de implementación.
\end{compactitem}

Además, una buena práctica consiste en incluir la capacidad de revertir automáticamente todos los cambios aplicados en el despliegue.

\subsection{Documentación y “feedback”}
Muchos desarrolladores trabajan bajo la firme creencia de que la documentación pertenece al código fuente, de hecho, ese código claro y conciso con nombres de métodos, variables y clases bien elegidos es la mejor documentación. No obstante, un sistema CI también puede proporcionar bastantes beneficios en lo que a la documentación se refiere. Una característica fundamental de los buenos sistemas de CI es la velocidad, y su esencia es proporcionar retroalimentación oportuna a los desarrolladores y partes interesadas del proyecto. Para generar documentación se pueden utilizar herramientas como Maven, Javadoc o NDoc y, además, existen otras herramientas que pueden generar diagramas de clase y e información relevante, todo basado en el código fuente subido o “committed” al repositorio de control de versiones.

\section{Valor de la integración continua}
A alto nivel, el valor u objetivos de la integración continua serían:
\begin{enumerate}
    \item Reducir riesgos.
    \item Reducir procesos manuales repetitivos.
    \item Generar software desplegable en cualquier momento y en cualquier lugar.
    \item Habilitar una mejor visibilidad del proyecto.
    \item Establecer una mayor confianza en el producto software del equipo de desarrollo.
\end{enumerate}
\subsection{Reducir riesgos}
Integrando muchas veces al día se pueden reducir los riesgos de un proyecto software. Llevarlo a cabo facilita la detección de defectos, la medición del estado del software y la reducción de suposiciones.
\begin{compactitem}
    \item Los defectos se detectan y se solucionan antes: debido a que CI integra y ejecuta pruebas e inspecciones varias veces al día, existe una mayor probabilidad de que los defectos se descubran en el momento en el que son introducidos en el proyecto (es decir, cuando el código se registra en el repositorio de control de versiones) en lugar de durante las pruebas de último ciclo.
    \item El estado del software se puede medir: al incorporar pruebas e inspecciones continuas en el proceso de integración automatizado, los atributos de estado del producto de software (como la complejidad por ejemplo) se pueden rastrear a lo largo del tiempo.
    \item Reduce las suposiciones: al reconstruir y probar el software en un entorno limpio utilizando el mismo proceso y los mismos scripts de forma continua, se pueden reducir las suposiciones (ya sean porque se estuviesen contabilizando librerías de terceros o que se estuviesen utilizando variables de entorno, por ejemplo).
\end{compactitem}
La integración continua proporciona una red de seguridad para reducir el riesgo de que se introduzcan defectos en el código fuente. Los siguientes son algunos de los riesgos que CI ayuda a mitigar:
\begin{compactitem}
    \item Falta de software cohesivo e implementable.
    \item Descubrimiento tardío de defectos.
    \item Software de baja calidad.
    \item Falta de visibilidad del proyecto.
\end{compactitem}
\subsection{Reducir procesos repetitivos}
los procesos repetitivos pueden ocurrir en todas las actividades del proyecto, incluida la compilación de código, la integración de la base de datos, las pruebas, la inspección del código fuente, el despliegue y la retroalimentación o “feedback” y reducirlos supone un ahorro en tiempo, coste y esfuerzo. Al utilizar integración continua se aumenta la capacidad de garantizar los siguientes aspectos:
\begin{compactitem}
    \item El proceso se ejecuta de la misma manera cada vez.
    \item Se sigue un proceso ordenado.
    \item Los procesos se ejecutarán cada vez que se produzca una confirmación en el repositorio de control de versiones. 
    \item La reducción del trabajo en procesos repetitivos libera a las personas para que realicen trabajo de mayor valor.
    \item La capacidad de superar la resistencia (de otros miembros) para implementar mejoras mediante el uso de mecanismos automatizados para procesos importantes como las pruebas.
\end{compactitem}
\subsection{Generar software desplegable}
CI permite lanzar software desplegable en cualquier momento de tiempo, y desde una perspectiva externa, este es el beneficio más obvio de la integración continua. Se podría hablar interminablemente sobre la mejora de la calidad del software y la reducción de los riesgos, pero el software desplegable es el activo más tangible para aquellas personas que no estén tan habituadas a ver e interpretar código fuente, como clientes o usuarios.
\subsection{Habilitar una mejor visibilidad del proyecto}
CI proporciona la capacidad de notar tendencias y tomar decisiones efectivas, ayudando a la hora de poder innovar en nuevas mejoras. Los proyectos software sufren cuando no hay datos reales o recientes para respaldar las decisiones que se toman, dando lugar a que todos ofrezcan sus mejores conjeturas. Por lo general, los miembros de un proyecto recopilan esta información manualmente, lo que supone mucho esfuerzo y que, a menudo, la información nunca se recopile. 

CI tiene los siguientes efectos positivos:
\begin{compactitem}
    \item Decisiones eficaces: un sistema de CI puede proporcionar información justo a tiempo sobre el estado de construcción reciente y las métricas de calidad. Algunos sistemas de CI también pueden mostrar tasas de defectos y estados de finalización de características.
    \item Notar tendencias: dado que la integración de proyectos ocurre con frecuencia con un sistema de CI, la capacidad de notar tendencias en el éxito o el fracaso de la construcción, la calidad general u otra información pertinente del proyecto se vuelve posible.
\end{compactitem}
\subsection{Establecer una mayor confianza en el producto}
En general, la aplicación eficaz de las prácticas de CI puede proporcionar una mayor confianza en la producción de un producto de software. Con cada compilación, el equipo de desarrollo es consciente de que se ejecutan pruebas contra el software para verificar el comportamiento, que se cumplen los estándares de codificación y diseño del proyecto. El hecho de que un sistema de CI pueda informar de si algo sale mal implica que los desarrolladores y otros miembros del equipo tengan más confianza a la hora de poder realizar cambios.

\section{Herramientas de integración continua}
Actualmente existen una gran cantidad de herramientas de integración continua, a comentar, por su grado de relevancia y uso, las siguientes:

\begin{compactitem}
    \item \textbf{\underline{Jenkins}}: es un servidor de automatización de código abierto autónomo que se puede utilizar para automatizar todo tipo de tareas relacionadas con la creación, prueba y entrega o implementación de software.\\
    Puede instalarse a través de paquetes del sistema nativo, Docker o incluso ejecutarse de forma independiente en cualquier máquina que tenga instalado Java Runtime Environment (JRE).
    \begin{figure}[h]
        \centering
        \includegraphics[width=0.3\textwidth,clip=true]{\logoJenkins}
        \caption{Logo de Jenkins.}
    \end{figure}
    \item \textbf{\underline{Travis}}: escrito en Ruby, es un servicio de integración continua que se utiliza para crear y probar proyectos de software alojados en GitHub, Bitbucket, GitLab y Assembla. Fue el primer servicio de CI que permitió realizar el proceso de integración continua a proyectos de código abierto de forma gratuita.
    
    \begin{figure}[h]
        \centering
        \includegraphics[width=0.3\textwidth,clip=true]{\logoTravis}
        \caption{Logo de Travis.}
    \end{figure}
    
    Las principales funciones de Travis CI son:
    \begin{compactitem}
        \item Configuración rápida.
        \item Vistas de construcción en vivo.
        \item Servicios de base de datos preinstalados.
        \item Implementaciones automáticas en compilaciones pasadas.
        \item Limpieza de VM para cada compilación.
        \item Compatibilidad con Mac, Linux e iOS.
    \end{compactitem}
    \item \textbf{\underline{Circle CI}}: servicio de integración continua cuyas principales características son las siguientes:
    \begin{compactitem}
        \item Flujos de trabajo para la orquestación de tareas.
        \item Soporte con Docker.
        \item Selección de CPU y RAM para adaptar las canalizaciones al equipo.
        \item Soporte independiente del idioma: se admite cualquier idioma que se desarrolle en Linux, Windows o macOS.
        \item Potente almacenamiento en caché.
        \item SSH o ejecución de compilaciones locales para una depuración sencilla.
        \item Seguridad: LDAP para administración de usuarios, aislamiento de máquinas virtuales a nivel completo y más.
        \item Panel de información: seguimiento del estado y optimización de canalizaciones con facilidad.
    \end{compactitem}
    Además, cuenta con dos opciones de hospedaje: en la nube o en servidor y con tres opciones de precios: ``Free'' 0 dólares al mes, ``Performance'' 30 dólares al mes y ``Scale'' con un precio a medida.
    \begin{figure}[h]
        \centering
        \includegraphics[width=0.3\textwidth,clip=true]{\logoCircleCI}
        \caption{Logo de Circle CI.}
    \end{figure}
    \item \textbf{\underline{GitHub Actions}}: las acciones de GitHub ayudan a automatizar tareas dentro del ciclo de vida de un desarrollo de software. Están controladas por eventos, lo que significa que pueden ejecutar una serie de comandos después de que se haya producido un evento específico. Por ejemplo, cada vez que alguien crea una solicitud de extracción para un repositorio, puede ejecutar automáticamente un comando que ejecuta un script de prueba de software.
    \begin{figure}[h]
        \centering
        \includegraphics[width=0.45\textwidth,clip=true]{\logoGitHubActions}
        \caption{Logo de GitHub Actions.}
    \end{figure}
    
    El siguiente diagrama muestra cómo se pueden usar las acciones de GitHub para ejecutar automáticamente scripts de prueba de software: un evento activa automáticamente un “flujo de trabajo”, que contiene un trabajo. Luego, el trabajo usa pasos para controlar el orden en el que se ejecutan las acciones. Estas acciones son los comandos que automatizan las pruebas de software. Además, hay múltiples componentes de GitHub Actions que trabajan juntos para ejecutar trabajos.
    \begin{figure}[h]
        \centering
        \includegraphics[width=0.4\textwidth,clip=true]{\githubActionsDiagram}
        \caption{Diagrama GitHub Actions.}
    \end{figure}
    \item \textbf{\underline{Azure pipelines}}: compila y prueba automáticamente proyectos de código para que estén disponibles para otros usuarios. Funciona con prácticamente cualquier tipo de proyecto o lenguaje.
    \begin{figure}[h]
        \centering
        \includegraphics[width=0.4\textwidth,clip=true]{\logoAzurePipelines}
        \caption{Logo de Azure Pipelines.}
    \end{figure}
    
    Sus principales características son:
    \begin{compactitem}
        \item Cualquier lenguaje, cualquier plataforma: permite compilar, probar e implementar aplicaciones de Node.js, Python, Java, PHP, Ruby, C/C++, .NET, iOS y Android. Además, permite ejecutar archivos en paralelo en Linux, macOS y Windows.
        \item Contenedores y Kubernetes: permite compilar e insertar fácilmente imágenes en registros de contenedor, como Docker Hub y Azure Container Registry. Además, permite implementar contenedores en hosts individuales o en Kubernetes.
        \item Extensible: ya que deja explorar e implementar una gran variedad de tareas de compilación, pruebas e implementación creadas por la comunidad, junto con cientos de extensiones, desde Slack hasta SonarCloud.
        \item Soluciones en cualquier nube: disponible la entrega continua (CD) del software en cualquier nube como Azure, AWS y GCP.
        \item Gratis para código abierto: asegura canalizaciones rápidas de integración y entrega continuas (CI/CD) para proyectos de código abierto.
        \item Características y flujos de trabajo avanzados: compatibilidad con YAML, integración de pruebas, validación de versiones, informes, etc.
    \end{compactitem}
    \item \textbf{\underline{Bamboo}}: Atlassian Bamboo es un servidor de integración continua (CI) e implementación que ayuda a los equipos de desarrollo de software proporcionando:
    \begin{compactitem}
        \item creación y prueba automatizadas del estado del código fuente del software.
        \item actualizaciones en compilaciones correctas y fallidas.
        \item herramientas de presentación de informes para el análisis estadístico.
    \end{compactitem}
    \begin{figure}[h]
        \centering
        \includegraphics[width=0.3\textwidth,clip=true]{\logoBamboo}
        \caption{Logo de Bamboo.}
    \end{figure}
    \item \textbf{\underline{GitLab CI}}: es la parte de GitLab que usa para todos los métodos continuos (Integración continua, Entrega e Implementación). Con GitLab CI/CD, puede probar, crear y publicar su software sin necesidad de una aplicación o integración de terceros.
    \begin{figure}[h]
        \centering
        \includegraphics[width=0.15\textwidth,clip=true]{\logoGitLabCI}
        \caption{Logo de GitLab CI.}
    \end{figure}
    \item \textbf{\underline{Codeship}}: CloudBees CodeShip es una solución de software como servicio (SaaS) que permite a los equipos de ingeniería implementar y optimizar CI y CD en la nube. Ayuda a los equipos pequeños y en crecimiento a desarrollar todo, desde aplicaciones web simples hasta arquitecturas de microservicios modernas para lograr una entrega de código rápida, segura y frecuente.
    \begin{figure}[h]
        \centering
        \includegraphics[width=0.3\textwidth,clip=true]{\logoCodeship}
        \caption{Logo de Codeship.}
    \end{figure}
    \item \textbf{\underline{TeamCity}}: es un servidor comercial de CI/CD que también está basado en Java (al igual que Jenkins). Es una herramienta de gestión y automatización de compilación creada por JetBrains.
    Es compatible con .NET framework y puede integrar fácilmente con varios IDEs como Eclipse o Visual Studio.
    Cuenta con tres planes:
    \begin{compactitem}
        \item TeamCity Cloud.
        \item TeamCity Professional.
        \item TeamCity Enterprise.
    \end{compactitem}
    \begin{figure}[h]
        \centering
        \includegraphics[width=0.4\textwidth,clip=true]{\logoTeamCity}
        \caption{Logo de TeamCity.}
    \end{figure}
    \item \textbf{\underline{Semaphore CI}}: es un servicio de automatización basado en la nube para crear, probar e implementar software. Diseñado para la productividad del desarrollador y guiado por tres principios:
    \begin{compactitem}
        \item Velocidad: los desarrolladores deben trabajar en un ciclo de retroalimentación rápido, por lo que los flujos de trabajo de CI/CD deben ser rápidos.
        \item Potencia: la herramienta de CI/CD debe poder ejecutar cualquier flujo de trabajo de software automatizado, a cualquier escala.
        \item Facilidad de uso: CI/CD debe ser lo suficientemente fácil de usar para que todos los desarrolladores estén en estrecho contacto con el funcionamiento de su software y su impacto en los usuarios.
    \end{compactitem}
    Cuenta con tres planes de pago:
    \begin{compactitem}
        \item Free.
        \item Startup.
        \item Enterpirise Cloud.
    \end{compactitem}
    \begin{figure}[h]
        \centering
        \includegraphics[width=0.4\textwidth,clip=true]{\logoSemaphore}
        \caption{Logo de Semaphore CI.}
    \end{figure}
    \item \textbf{\underline{Bazel}}: es otra herramienta de integración continua que ofrece las siguientes ventajas:
    \begin{compactitem}
        \item Lenguaje de construcción de alto nivel. Bazel utiliza un lenguaje abstracto y legible por humanos para describir las propiedades de construcción de su proyecto en un alto nivel semántico. A diferencia de otras herramientas, Bazel opera con los conceptos de bibliotecas, binarios, scripts y conjuntos de datos, protegiéndolo de la complejidad de escribir llamadas individuales a herramientas como compiladores y enlazadores.
        \item Rápido y fiable. Bazel almacena en caché todo el trabajo realizado anteriormente y realiza un seguimiento de los cambios tanto en el contenido del archivo como en los comandos de compilación. De esta forma, Bazel sabe cuándo es necesario reconstruir algo y solo lo hace. Para acelerar aún más sus compilaciones, puede configurar su proyecto para que se construya de una manera altamente paralela e incremental.
        \item Multiplataforma. Bazel se ejecuta en Linux, macOS y Windows. Bazel puede crear binarios y paquetes implementables para múltiples plataformas, incluidas computadoras de escritorio, servidores y dispositivos móviles, desde el mismo proyecto.
        \item Escala. Bazel mantiene la agilidad mientras maneja compilaciones con más de 100 000 archivos fuente. Funciona con múltiples repositorios y bases de usuarios de decenas de miles.
        \item Extensible. Se admiten muchos idiomas y puede ampliar Bazel para admitir cualquier otro idioma o marco.
    \end{compactitem}
    \begin{figure}[h]
        \centering
        \includegraphics[width=0.3\textwidth,clip=true]{\logoBazel}
        \caption{Logo de Bazel CI.}
    \end{figure}
\end{compactitem}

Como se ha visto, a pesar de esistir una infinidad de herramientas de integración continua, todas ellas nos van a ofrecer en definitiva recursos muy parecidos para poder integrar nuestros proyectos.

Otras herramientas a mencionar que nos ofrecen características similares de integración continua son: GoCD, Shippable, Buildkite, Codefresh, Buddy, Buildbot, Wercker, Integrity, WeaveFlux, NeverCode, AutoRABIT, Bitrise, Drone CI, UrbanCode, Strider CD y FinalBuilder.

\section{Estructura del documento}

La estructura del TFG no es fija. El tutor indicará una estructura adecuada dependiendo del trabajo concreto.\tutor{Comentario del tutor}

Se puede incluir dentro de cada apartado secciones adicionales. La copia en papel de la memoria del TFG será encuadernada en pasta dura de color azul (p.e. encuadernación tipo chanel). La portada, que puede ser una pegatina transparente, seguirá el modelo que se adjunta, que incluye el escudo y nombre de la URJC, la titulación cursada por el alumno, el curso académico, el título del TFG, el autor y el o los directores/tutores.\alumno{Comentario del alumno}

\subsection{Trabajos de grados en informática}

Una posible estructura de la memoria final asociada con cada TFG podría ser la siguiente (leed la normativa de TFG):
\begin{enumerate}
 \item Introducción
 \item Objetivos (incluyendo descripción del problema, estudio de alternativas y metodología empleada)
 \item Descripción informática (puede incluir especificación, diseño, implementación y pruebas).
 \item Experimentos / validación
 \item Conclusiones (incluyendo los logros principales alcanzados y posibles trabajos futuros)
 \item Bibliografía
 \item Apéndices
\end{enumerate}
